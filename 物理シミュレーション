function doGet() {
  return HtmlService.createHtmlOutput(`
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f0f0; touch-action: manipulation; }
  h3 { margin: 10px; color: #333; }
  canvas { background: #fff; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0,0,0,0.1); }
  .controls { margin-top: 15px; display: flex; gap: 15px; }
  button { padding: 10px 20px; font-size: 16px; border: none; border-radius: 5px; cursor: pointer; background: #007bff; color: white; }
  button:active { background: #0056b3; }
  button.reset { background: #6c757d; }
  .info { margin-top: 10px; font-size: 14px; color: #555; font-weight: bold;}
</style>
</head>
<body>

<h3>物理：円筒面をすべる小物体</h3>
<canvas id="simCanvas" width="600" height="400"></canvas>

<div class="controls">
  <button onclick="startSim()">スタート</button>
  <button class="reset" onclick="resetSim()">リセット</button>
</div>
<div class="info" id="statusText">状態: 停止中</div>

<script>
  const canvas = document.getElementById('simCanvas');
  const ctx = canvas.getContext('2d');
  
  // --- パラメータ設定 ---
  const R = 120; // 円筒の描画上の半径 (px)
  const g = 9.8; 
  const timeScale = 0.6; // アニメーション速度調整
  
  // 配置設定
  const floorY = canvas.height - 50; // 床のY座標
  const ox = canvas.width / 2;       // 円の中心X座標
  const oy = floorY - R;             // 円の中心Y座標
  
  // 分離角度 (cosθ = 2/3)
  const SEP_ANGLE = Math.acos(2/3);

  // --- 状態変数 ---
  let time = 0;
  let running = false;
  const INITIAL_ANGLE = 0.005; // スタート時の微小角度
  let angle = INITIAL_ANGLE; 
  let separated = false; 
  
  // 分離時の情報
  let sepTime = 0; 
  let sepPos = {x:0, y:0}; 
  let sepVel = {x:0, y:0}; 
  
  let animReq;
  let lastTime = 0;

  // 初期描画
  draw();

  function startSim() {
    // 落下完了後などはリセットしてからスタート
    if (!running) {
      if (angle > INITIAL_ANGLE && !separated) {
         // 途中停止からの再開ならそのまま
      } else if (separated && angle >= SEP_ANGLE) {
         // 落下後ならリセット
         resetSim();
         running = true; 
         lastTime = performance.now();
         loop();
         return;
      }
      
      running = true;
      lastTime = performance.now();
      loop();
    }
  }

  function resetSim() {
    running = false;
    cancelAnimationFrame(animReq);
    time = 0;
    angle = INITIAL_ANGLE;
    separated = false;
    document.getElementById('statusText').innerText = "状態: 停止中";
    draw();
  }
  
  function loop() {
    if (!running) return;
    
    const now = performance.now();
    let dt = ((now - lastTime) / 1000) * timeScale; 
    if(dt > 0.05) dt = 0.05; 
    lastTime = now;
    time += dt;

    updatePhysics(dt);
    draw();
    
    if (running) {
       animReq = requestAnimationFrame(loop);
    }
  }

  function updatePhysics(dt) {
    if (!separated) {
      // --- 円運動フェーズ ---
      const real_R = 5.0; 
      const v_real = Math.sqrt(2 * g * real_R * (1 - Math.cos(angle)));
      const angular_vel = v_real / real_R;
      angle += angular_vel * dt;

      // 分離判定
      if (angle >= SEP_ANGLE) {
         setupSeparation(SEP_ANGLE, time);
         // ★変更点: ここでrunning = falseにせず、そのまま放物運動へ移行させる
      }
      document.getElementById('statusText').innerText = "状態: 円筒面上を滑走中";
      
    } else {
      // --- 放物運動フェーズ ---
      // 現在位置の更新（draw内で計算していたものを判定用にここで計算）
      const t_dash = time - sepTime;
      const g_px = g * (R / 5.0);
      
      // 次の瞬間のY座標を予測
      const nextY = sepPos.y + sepVel.y * t_dash + 0.5 * g_px * t_dash * t_dash; 

      // 床判定 (物体の半径10px考慮)
      if (nextY + 10 >= floorY) { 
          running = false;
          // 埋まらないように位置補正して終了
          time = sepTime + getFallTime(floorY - 10 - sepPos.y, sepVel.y, g_px);
          document.getElementById('statusText').innerText = "状態: 床に落下しました";
          draw();
      } else {
         document.getElementById('statusText').innerText = "状態: 放物運動中 (抗力ゼロ)";
      }
    }
  }

  // 二次方程式の解の公式で正確な落下時間を逆算（着地位置ズレ防止）
  function getFallTime(dy, vy, acc) {
      // dy = vy*t + 0.5*acc*t^2  => 0.5*acc*t^2 + vy*t - dy = 0
      const D = vy*vy - 4 * (0.5*acc) * (-dy);
      if(D < 0) return 0;
      return (-vy + Math.sqrt(D)) / acc;
  }

  function setupSeparation(sAngle, t) {
      separated = true;
      angle = sAngle; // 角度変数はここで固定
      sepTime = t;
      
      sepPos = { x: ox + R * Math.sin(sAngle), y: oy - R * Math.cos(sAngle) };
      
      const real_R = 5.0;
      const v_sep = Math.sqrt(2 * g * real_R / 3);
      const v_px = v_sep * (R / real_R);
      
      sepVel = { x: v_px * Math.cos(sAngle), y: v_px * Math.sin(sAngle) };
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 床
    ctx.beginPath();
    ctx.moveTo(0, floorY);
    ctx.lineTo(canvas.width, floorY);
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.fillStyle = "#ddd";
    ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);

    // 円筒
    ctx.beginPath();
    ctx.arc(ox, oy, R, 0, Math.PI * 2); 
    ctx.fillStyle = "#e0e0e0";
    ctx.fill();
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // 中心O
    ctx.fillStyle = "black";
    ctx.beginPath(); ctx.arc(ox, oy, 3, 0, Math.PI*2); ctx.fill();
    ctx.fillText("O", ox + 5, oy + 15);

    // 物体の座標計算
    let px, py;
    let N_mag = 0;

    if (!separated) {
      px = ox + R * Math.sin(angle);
      py = oy - R * Math.cos(angle);
      const factor = 3 * Math.cos(angle) - 2;
      N_mag = Math.max(0, factor * 80); 
    } else {
      const dt = time - sepTime;
      const g_px = g * (R / 5.0); 
      px = sepPos.x + sepVel.x * dt;
      py = sepPos.y + sepVel.y * dt + 0.5 * g_px * dt * dt;
      N_mag = 0;
    }

    // --- ★修正箇所: 角度θの表示 ---
    // 離れた後は「離れた瞬間の角度」で固定表示する
    const displayAngle = separated ? SEP_ANGLE : angle;
    
    if (displayAngle > 0.1) {
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 1;

        // P点方向（上）
        ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(ox, oy - R - 15); ctx.stroke();
        ctx.font = "16px Arial";
        ctx.fillStyle = "black";
        ctx.fillText("P", ox - 5, oy - R - 20);

        // 角度線（物体の方向 or 離れた点Sの方向）
        const targetX = ox + R * Math.sin(displayAngle);
        const targetY = oy - R * Math.cos(displayAngle);
        ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(targetX, targetY); ctx.stroke();

        ctx.setLineDash([]); // 実線に戻す

        // 角度の弧
        ctx.beginPath();
        ctx.arc(ox, oy, R * 0.4, -Math.PI/2, -Math.PI/2 + displayAngle);
        ctx.strokeStyle = "black";
        ctx.stroke();
        ctx.font = "18px serif";
        ctx.fillText("θ", ox + R*0.1, oy - R*0.45);
    }

    // ベクトル描画
    drawVector(px, py, 0, 50, "blue"); // 重力
    if (N_mag > 1) {
       // 抗力は「現在の物体の位置」ではなく「円筒面にいると仮定した角度」で描くべきだが
       // 離れた後はN=0なので描画されない。円運動中のみ描画。
       const nx = Math.sin(angle); const ny = -Math.cos(angle);
       drawVector(px, py, nx * N_mag, ny * N_mag, "red"); 
    }

    // 物体
    ctx.beginPath();
    ctx.arc(px, py, 12, 0, Math.PI * 2);
    ctx.fillStyle = "#ff9800";
    ctx.fill();
    ctx.stroke();
    
    // ガイド点S
    const sx = ox + R * Math.sin(SEP_ANGLE);
    const sy = oy - R * Math.cos(SEP_ANGLE);
    ctx.fillStyle = "#999";
    ctx.beginPath(); ctx.arc(sx, sy, 4, 0, Math.PI*2); ctx.fill();
    ctx.font = "16px Arial";
    ctx.fillText("S", sx + 10, sy - 5);
  }

  function drawVector(x, y, vx, vy, color) {
    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + vx, y + vy);
    ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.stroke();
    const headLen = 10; const angle = Math.atan2(vy, vx);
    ctx.beginPath();
    ctx.moveTo(x + vx, y + vy);
    ctx.lineTo(x + vx - headLen * Math.cos(angle - Math.PI/6), y + vy - headLen * Math.sin(angle - Math.PI/6));
    ctx.lineTo(x + vx - headLen * Math.cos(angle + Math.PI/6), y + vy - headLen * Math.sin(angle + Math.PI/6));
    ctx.fillStyle = color; ctx.fill();
  }
</script>
</body>
</html>
  `).setTitle('物理シミュレーション v4');
}
