function doGet() {
  return HtmlService.createHtmlOutput(`
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f0f0; touch-action: manipulation; }
  h3 { margin: 10px; color: #333; }
  canvas { background: #fff; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0,0,0,0.1); }
  .controls { margin-top: 15px; display: flex; gap: 15px; }
  button { padding: 10px 20px; font-size: 16px; border: none; border-radius: 5px; cursor: pointer; background: #007bff; color: white; }
  button:active { background: #0056b3; }
  button.reset { background: #6c757d; }
  .info { margin-top: 10px; font-size: 14px; color: #555; }
</style>
</head>
<body>

<h3>物理：円筒面をすべる小物体</h3>
<canvas id="simCanvas" width="600" height="400"></canvas>

<div class="controls">
  <button onclick="startSim()">スタート</button>
  <button class="reset" onclick="resetSim()">リセット</button>
</div>
<div class="info" id="statusText">状態: 停止中</div>

<script>
  const canvas = document.getElementById('simCanvas');
  const ctx = canvas.getContext('2d');
  
  // --- パラメータ設定 ---
  const R = 150; // 円筒の描画上の半径 (px)
  const g = 9.8; // 重力加速度
  const timeScale = 0.5; // スローモーション具合（数値を上げると速くなる）
  
  // 原点（キャンバス上の位置）
  const ox = canvas.width / 2;
  const oy = canvas.height * 0.7;

  // --- 状態変数 ---
  let time = 0;
  let running = false;
  // ★修正点: 完全に0だと動かないため、微小な角度(約0.3度)から開始します
  const INITIAL_ANGLE = 0.005; 
  let angle = INITIAL_ANGLE; 
  let separated = false; 
  
  // 分離時の情報を保存する変数
  let sepTime = 0; 
  let sepPos = {x:0, y:0}; 
  let sepVel = {x:0, y:0}; 
  
  let animReq;
  let lastTime = 0;

  // 初期描画
  draw();

  function startSim() {
    if (!running) {
      running = true;
      lastTime = performance.now();
      loop();
    }
  }

  function resetSim() {
    running = false;
    cancelAnimationFrame(animReq);
    time = 0;
    angle = INITIAL_ANGLE; // 角度を初期位置に戻す
    separated = false;
    document.getElementById('statusText').innerText = "状態: 停止中";
    draw();
  }
  
  function loop() {
    if (!running) return;
    
    const now = performance.now();
    // 経過時間(dt)の計算。動きがカクつかないよう最大値を制限
    let dt = ((now - lastTime) / 1000) * timeScale; 
    if(dt > 0.05) dt = 0.05; 
    lastTime = now;
    
    time += dt;

    updatePhysics(dt);
    draw();
    
    // 画面外に出たら停止判定（簡易的）
    let currentY;
    if(!separated) {
      currentY = oy - R * Math.cos(angle);
    } else {
      // 放物運動の現在位置Y
      const t_dash = time - sepTime;
      // 画面上のピクセル換算重力加速度: g_px = g * (ピクセルR / 実際のメートルR)
      // ここでは R=5m と仮定して計算
      const g_px = g * (R / 5.0);
      currentY = sepPos.y + sepVel.y * t_dash + 0.5 * g_px * t_dash * t_dash; 
    }

    if (currentY > canvas.height + 20) { // 画面下少し過ぎたら停止
       running = false;
       document.getElementById('statusText').innerText = "状態: 落下完了";
    } else {
       animReq = requestAnimationFrame(loop);
    }
  }

  function updatePhysics(dt) {
    // 分離条件: cos(θ) = 2/3 (約48.2度)
    const sepAngle = Math.acos(2/3);

    if (!separated) {
      // --- 円運動フェーズ ---
      
      // エネルギー保存則から速度 v を計算
      // v = √(2gR(1 - cosθ))
      // ここでは R=5m と仮定
      const real_R = 5.0; 
      const v_real = Math.sqrt(2 * g * real_R * (1 - Math.cos(angle)));
      
      // 角速度 ω = v / R
      const angular_vel = v_real / real_R;

      // 角度を更新 (θ = θ + ω * dt)
      // ※vが0に近い初期は動きが遅いため、最低限の微小速度がないと進まないが、
      // 初期角度0.005があるため自然に加速します。
      angle += angular_vel * dt;

      // 分離角度を超えたかチェック
      if (angle >= sepAngle) {
         setupSeparation(sepAngle, time);
      }
      
      document.getElementById('statusText').innerText = "状態: 円筒面上を滑走中";
      
    } else {
      // --- 放物運動フェーズ ---
      document.getElementById('statusText').innerText = "状態: 放物運動 (抗力ゼロ)";
    }
  }

  function setupSeparation(sAngle, t) {
      separated = true;
      angle = sAngle; // 角度を厳密に合わせる
      sepTime = t;
      
      // 分離位置 (Canvas座標)
      sepPos = {
        x: ox + R * Math.sin(sAngle),
        y: oy - R * Math.cos(sAngle)
      };

      // 分離時の速度ベクトル計算
      const real_R = 5.0;
      // 分離時の速さ v = √(2gR/3)
      const v_sep = Math.sqrt(2 * g * real_R / 3);
      const v_px = v_sep * (R / real_R); // ピクセル単位に変換

      // 速度の向きは接線方向
      sepVel = {
        x: v_px * Math.cos(sAngle),
        y: v_px * Math.sin(sAngle) 
      };
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 1. 円筒（半円）
    ctx.beginPath();
    ctx.arc(ox, oy, R, Math.PI, 0); 
    ctx.fillStyle = "#e0e0e0";
    ctx.fill();
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // 床
    ctx.beginPath();
    ctx.moveTo(0, oy);
    ctx.lineTo(canvas.width, oy);
    ctx.strokeStyle = "#333";
    ctx.stroke();

    // 2. 物体の位置計算
    let px, py;
    let N_mag = 0; // 垂直抗力の大きさ

    if (!separated) {
      px = ox + R * Math.sin(angle);
      py = oy - R * Math.cos(angle);
      
      // 垂直抗力 N ∝ 3cosθ - 2
      const factor = 3 * Math.cos(angle) - 2;
      N_mag = Math.max(0, factor * 80); 
      
    } else {
      // 放物運動の位置計算
      const dt = time - sepTime;
      const g_px = g * (R / 5.0); 
      
      px = sepPos.x + sepVel.x * dt;
      py = sepPos.y + sepVel.y * dt + 0.5 * g_px * dt * dt;
      N_mag = 0;
    }

    // 3. ベクトル描画
    // 重力 (青, 常に一定)
    drawVector(px, py, 0, 50, "blue"); 

    // 垂直抗力 (赤, だんだん小さくなる)
    if (N_mag > 1) {
       const nx = Math.sin(angle);
       const ny = -Math.cos(angle);
       drawVector(px, py, nx * N_mag, ny * N_mag, "red");
    }

    // 4. 物体を描画
    ctx.beginPath();
    ctx.arc(px, py, 12, 0, Math.PI * 2);
    ctx.fillStyle = "#ff9800"; // オレンジ
    ctx.fill();
    ctx.stroke();
    
    // ガイド点S (分離点)
    const s_angle = Math.acos(2/3);
    const sx = ox + R * Math.sin(s_angle);
    const sy = oy - R * Math.cos(s_angle);
    ctx.fillStyle = "#999";
    ctx.beginPath(); ctx.arc(sx, sy, 4, 0, Math.PI*2); ctx.fill();
    ctx.fillText("S", sx + 10, sy - 5);
  }

  // 矢印を描く関数
  function drawVector(x, y, vx, vy, color) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + vx, y + vy);
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.stroke();
    
    const headLen = 10;
    const angle = Math.atan2(vy, vx);
    ctx.beginPath();
    ctx.moveTo(x + vx, y + vy);
    ctx.lineTo(x + vx - headLen * Math.cos(angle - Math.PI / 6), y + vy - headLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(x + vx - headLen * Math.cos(angle + Math.PI / 6), y + vy - headLen * Math.sin(angle + Math.PI / 6));
    ctx.fillStyle = color;
    ctx.fill();
  }
</script>

</body>
</html>
  `).setTitle('物理シミュレーション');
}
